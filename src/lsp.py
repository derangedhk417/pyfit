# Authors: Adam Robinson, James Hickman
# This file generates the local structure parameters (lsp's) for a dataset.

import numpy as np
from util import ProgressBar

# Given a neighbor list structure in the format generated by 
# neighbor.py -> GenerateNeighborList, will generate local structure parameters
# in the conventional order, based on the hyperparameters defined in the 
# neural network potential configuration supplied (NetworkPotential.config)
def GenerateLocalStructureParams(neighbor_list, potential_config, log=None):

	if log is not None:
		log.log("Generating Local Structure Parameters")
		log.indent()

	# Here we compute the number of operations that will need
	# to take place in order to calculate the structural 
	# parameters. This is somewhat of an estimate, but the
	# operation should scale roughly by a factor of n^2.
	# In practice, this has generally been an excellent estimate.
	n_total     = 0
	for struct in neighbor_list:
		for atom in struct:
			n_total += (len(atom)**2 - len(atom)) / 2
	n_processed = 0

	progress = ProgressBar(
		"Structural Parameters ", 
		22, n_total, update_every = 8
	)

	structural_parameters = []

	parameters_per_atom  = potential_config.n_legendre_polynomials
	parameters_per_atom *= potential_config.n_r0
	# Here we iterate over every structure. And then
	# over every atom. We export the structural parameter
	# calculation for each individual atom to another function.
	for struct in neighbor_list:
		processed = 0
		# Iterate over all structures.
		parameters_for_structure = np.zeros((len(struct), parameters_per_atom))
		for idx, atom_neighbors in enumerate(struct):
			processed += (len(atom_neighbors)**2 - len(atom_neighbors)) / 2
			# Iterate over each atom in the structure and compute the 
			# parameters for it.
			parameters_for_structure[idx, :] = computeParameters(
				atom_neighbors, 
				potential_config
			)

		n_processed += processed
		progress.update(n_processed)

		structural_parameters.append(parameters_for_structure)

	progress.finish()

	if log is not None:
		log.log("Time Elapsed = %ss"%progress.ttc)
		log.unindent()

	return structural_parameters

# Given the neighbor list for a specific atom, as well as the network potential
# that defines the hyperparameters, computes the structural parameters for the
# atom.
def computeParameters(neighbors, potential_config):
	# First we need a list of every unique combination of
	# two neighbors, not considering [0, 1] to be unique 
	# compared to [1, 0]. More specifically, a different
	# order does not make the pair unique.
	length = neighbors.shape[0]

	grid         = np.mgrid[0:length, 0:length]
	grid         = grid.swapaxes(0, 2).swapaxes(0, 1)
	m            = grid.shape[0]
	r, c         = np.triu_indices(m, 1)
	combinations = grid[r, c]

	left_array  = neighbors[combinations[:,0]]
	right_array = neighbors[combinations[:,1]]

	# Now we use these pairs of vectors to compute and array of
	# cos(theta) values. Strangely enough, this appears to be the
	# fastest way to do this.
	dot_products = np.einsum('ij,ij->i', left_array, right_array)


	# This is the magnitude of all of the vectors in the left array.
	left_magnitudes    = np.linalg.norm(left_array, axis=1)

	# This is the magnitude of all of the vectors in the right array.
	right_magnitudes   = np.linalg.norm(right_array, axis=1)

	# The following two lines are essentially computing 
	# (r_i * r_j) / (|r_i||r_j|) where '*' denotes the dot product.
	magnitude_products = left_magnitudes * right_magnitudes
	angular_values     = dot_products / magnitude_products

	# Here we skip some steps and just add an array of 1.0 onto
	# the array of cos(theta) values. This is for all cases where
	# i = j, so we know for a fact that theta = 0 and cos(theta) = 1.0
	dupl_indices    = np.arange(0, length, 1)
	dupl_magnitudes = np.linalg.norm(neighbors[dupl_indices], axis=1)
	angular_values  = np.concatenate((angular_values, np.tile([1.0], length)))

	# angular values now holds an array of cos(theta_ijk) for all unique i, j.

	# Next, we need to compute and array of radial terms for each r0 value.
	s2 = 1.0/(potential_config.gi_sigma**2)

	# This is an array of all radial terms for 
	# all values of r0.
	radial_terms = []

	# These operations are not done inside of the subsequent loop, because 
	# their values do not vary with respect to r0. It is worth noting that 
	# you could do this inside of the loop without any slowdown, but that is 
	# because numpy will cache the values and does not compute them again when
	# it doesn't need to.

	# The computation involving tanh at the end of the cutoff function
	# terms is just a mathematical way of making fc be zero if r > rc.
	# Adding an if statement would require numpy to jump out of c code and
	# in to python code in order to evaluate it. This would significantly
	# slow down the operation. (During testing slowdown was 50 - 100 times)
	# see https://www.desmos.com/calculator/puz9hpi090
	# This has been thoroughly tested against some c code that uses an if 
	# statement. The results are bitwise identical for 9 large test cases.
	d4 = np.square(np.square(potential_config.truncation_distance))
	left_r_rc_unmodified = left_magnitudes - potential_config.cutoff_distance
	left_r_rc_terms  = np.square(np.square(left_r_rc_unmodified))
	left_fc          = (left_r_rc_terms / (d4 + left_r_rc_terms))
	left_fc         *= (0.5*np.tanh(-1e6*(left_r_rc_unmodified)) + 0.5)

	right_r_rc_unmodified = right_magnitudes - potential_config.cutoff_distance
	right_r_rc_terms  = np.square(np.square(right_r_rc_unmodified))
	right_fc          = (right_r_rc_terms / (d4 + right_r_rc_terms))
	right_fc         *= (0.5*np.tanh(-1e6*(right_r_rc_unmodified)) + 0.5)

	r_rc_unmodified  = dupl_magnitudes - potential_config.cutoff_distance
	r_rc_terms       = np.square(np.square(r_rc_unmodified))
	fc               = (r_rc_terms / (d4 + r_rc_terms))
	fc              *= (0.5*np.tanh(-1e6*(r_rc_unmodified)) + 0.5)

	# Here we calculate the radial term for all values of r0.
	for r0n in potential_config.r0:
		
		# The left_* and right_* arrays correspond to cases where 
		# r_i != r_j. In these cases, we need to calculate both of 
		# the functions (f) independently.
		left_term       = np.exp(-s2*np.square(left_magnitudes - r0n))
		full_left_term  = left_term*left_fc

		right_term      = np.exp(-s2*np.square(right_magnitudes - r0n))
		full_right_term = right_term*right_fc

		# These two arrays correspond to cases where r_i = r_j and we 
		# know that we just need to square the value of the function 
		# (f) after computing it once.
		term            = np.exp(-s2*np.square(dupl_magnitudes - r0n))
		full_term       = term*fc

		# In this statement, we multiply the radial term by 2, because 
		# cases where r_i != r_j are supposed to be repeated, with the 
		# vectors swapped. Since the function we are computing on them
		# is commutative, we  can just compute one case of r_i != r_j 
		# and double it to account for the case where r_i is swapped with 
		# r_j. This cuts the computation time in half.
		to_add = np.concatenate((
			2 * full_right_term * full_left_term, 
			np.square(full_term)
		))
		radial_terms.append(to_add)


	# Now radial_terms is an array where each first index corresponds 
	# to an r0 value and each second index corresponds to the product
	# of the radial terms for a unique combination of neighbors.

	# For each r0 and for each combination of neigbors, we now
	# Need to compute the m-th Legendre polynomial of the cosine
	# of the angle between the two.

	# This uses the recursive definition of the Legendre Polynomials
	# in order to generalize to any specified order in the nn file.

	max_pm = max(potential_config.legendre_orders)

	legendre_polynomials = np.zeros((
		max_pm + 1, 
		len(angular_values)
	))
	legendre_polynomials[0] = np.ones(len(angular_values))
	legendre_polynomials[1] = angular_values

	for order in range(1, max_pm):
		current_pm  = (2*order + 1)*angular_values*legendre_polynomials[order]
		current_pm -= order*legendre_polynomials[order - 1]
		current_pm /= (order + 1)
		legendre_polynomials[order + 1] = current_pm


	# Now we multiply the Legendre Polynomial terms by the radial terms and
	# sum them. This also selects the desired legendre polynomials from the
	# list of those computed. Since the recursive definition is used, legendre
	# polynomials may be computed that aren't actually used in the final 
	# result.
	len_pm = len(potential_config.legendre_orders)
	structural_parameters = np.zeros(len_pm * len(potential_config.r0))
	idx = 0
	for order in potential_config.legendre_orders:
		for r0n in radial_terms:
			current_param = np.sum(legendre_polynomials[order] * r0n)
			structural_parameters[idx] = current_param
			idx += 1

	# The following lines exist to adhere to a combination of the 
	# hyperparameter definition in the network potential file and the 
	# configuration values specified in the config file.
	sp  = structural_parameters
	sp /= np.square(np.tile(potential_config.r0, len_pm))
	
	if potential_config.gi_mode == 5:
		return np.arcsinh(sp)
	else:
		return sp